

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Simulating Membrane Potential &mdash; STEPS User Manual 2.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="STEPS User Manual 2.0.0 documentation" href="index.html" />
    <link rel="next" title="8. Preliminary Functionalities" href="preliminary_func.html" />
    <link rel="prev" title="6. SBML support" href="sbml_importer.html" /> 
  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="http://steps.sourceforge.net"><img src="_static/logo.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="preliminary_func.html" title="8. Preliminary Functionalities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="sbml_importer.html" title="6. SBML support"
             accesskey="P">previous</a> |</li>
        <li><a href="manual_index.html">STEPS User Manual 2.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="simulating-membrane-potential">
<span id="membrane-potential"></span><h1>7. Simulating Membrane Potential<a class="headerlink" href="#simulating-membrane-potential" title="Permalink to this headline">¶</a></h1>
<p><em>The simulation scripts described in this chapter are available at examples/tutorial/HH_APprop.py and examples/tutorial/runHH_APprop.py in STEPS 2.0.0 and above</em></p>
<p>This chapter introduces the concept of simulating the electric potential
across a membrane in STEPS, along with an introduction to new objects that
represent phenomena linked to the membrane potential simulation,
such as voltage-dependent channel transitions and currents across the membrane. We will
look at an example based on a very widely-used
model in computational neuroscience, the classical Hodgkin-Huxley model of the
action-potential, in molecular form. To demonstrate some useful techniques for
spatial simulations we will model action potential propagation in a simple mesh. As with previous chapters,
we will briefly introduce the model, then go through Python code used to run the
model in STEPS, with thorough descriptions where necessary.</p>
<div class="section" id="markov-gating-scheme">
<span id="mgs"></span><h2>7.1. Markov gating scheme<a class="headerlink" href="#markov-gating-scheme" title="Permalink to this headline">¶</a></h2>
<p>While many readers may not be familiar with conversion of the classical Hodgkin-Huxley (HH)
model to a Markov gating scheme we will only give a brief description here, though there are many
sources a reader may consult for a more detailed description (for example <a class="footnote-reference" href="#f1" id="id1">[1]</a>).
In brief, conductances are converted to a population of individual channels (each with single-channel
conductance of typically 20pS), and each individual channel may exist in one of a number of
states with rates described of possible first-order transitions to other states. Certain assumptions,
such as that the the rate constants do not depend on the history of the system (a Markov process),
and with the simplification that states with the same number of &#8216;open&#8217; and &#8216;closed&#8217; gates behave
identically regardless of specific configuration, lead to gating schemes as shown in
<a class="reference internal" href="#figure-7-1"><em>Figure 7.1</em></a> and <a class="reference internal" href="#figure-7-2"><em>Figure 7.2</em></a>
for the HH potassium and sodium channels respectively.</p>
<div class="figure" id="figure-7-1">
<img alt="_images/K.png" src="_images/K.png" style="width: 8.98in; height: 2.81in;" />
<p class="caption"><cite>Figure 7.1: In this representation the potassium channel is described by 4 gates which may be in open or closed configuration. State n3, for example, means that any 3 of the 4 gates are in open state. Where all 4 gates are open (state n4) the channel may conduct a current- all other states are non-conducting states.</cite></p>
</div>
<div class="figure" id="figure-7-2">
<img alt="_images/Na.png" src="_images/Na.png" style="width: 7.06in; height: 4.64in;" />
<p class="caption"><cite>Figure 7.2: The sodium channel is represented by 8 possible states- the m3h1 state is the conducting state.</cite></p>
</div>
<p>The transition rates (a<sub>n</sub>, b<sub>n</sub> for the potassium channel - a<sub>m</sub>, b<sub>m</sub>, a<sub>h</sub>, b<sub>h</sub> for the sodium channel)
should be very familiar to anyone well-acquainted with the HH model:</p>
<div class="math">
<p><img src="_images/math/d39d11326ce1b6f1074cc38761fec7f1422ef678.png" alt="a_n = \frac{0.01\times(10-(V+65))}{\exp\left(\frac{10-(V+65)}{10}\right)-1}"/></p>
</div><div class="math">
<p><img src="_images/math/017eea570faf2b2d933f9232e2ea354946257480.png" alt="b_n = 0.125\exp\left(\frac{-(V+65)}{80}\right)"/></p>
</div><div class="math">
<p><img src="_images/math/67f577ac44bb3d744f9d5371639f40e18a261c4e.png" alt="a_m = \frac{0.1\times(25-(V+65))}{\exp\left(\frac{25-(V+65)}{10}\right)-1}"/></p>
</div><div class="math">
<p><img src="_images/math/a217a5b3c1b67d3a1fbcb9e07536f497fae41678.png" alt="b_m = 4\exp\left(\frac{-(V+65)}{18}\right)"/></p>
</div><div class="math">
<p><img src="_images/math/28dc56478acce618c87ad6ef05e70984ad7a3af8.png" alt="a_h = 0.07\exp\left(\frac{-(V+65)}{20}\right)"/></p>
</div><div class="math">
<p><img src="_images/math/67b6bc470358322ed9cd8df923da531affb3dbfe.png" alt="b_h = \frac{1}{\exp\left(\frac{30-(V+65)}{10}\right)+1}"/></p>
</div><p>Where V is the potential across the membrane (in millivolts). Modelled as a stochastic process where each state is discretely populated, these functions form the basis of the propensity functions for each possible transition at any given voltage (here units are per millisecond). Voltage continously changes during simulation, yet over a short period of time the change is small enough so that the transition rates may be considered constant and stochastic algorithms applied. The transition rates must then be updated when the voltage change becomes large enough to merit a reevaluation of these functions.</p>
</div>
<div class="section" id="modelling-solution">
<h2>7.2. Modelling solution<a class="headerlink" href="#modelling-solution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="organisation-of-code">
<h3>7.2.1. Organisation of code<a class="headerlink" href="#organisation-of-code" title="Permalink to this headline">¶</a></h3>
<p>As in previous chapters we will go through code line-by-line from a script
used to run this simulation in STEPS, but this time without using the command prompt style.
Readers should note that actual indentation in the Python code and the indentation in the examples
here can be different, and indentation is very important in Python code.</p>
<p>The first thing to do is to import modules from STEPS that we need to run the simulation,
and assign them shorter names to reduce typing (for example <tt class="docutils literal"><span class="pre">smodel</span></tt> refers to <tt class="docutils literal"><span class="pre">steps.model</span></tt>).
In addition we will make use of modules numpy, math, time and random to assist with the simulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">steps.model</span> <span class="kn">as</span> <span class="nn">smodel</span>
<span class="kn">import</span> <span class="nn">steps.geom</span> <span class="kn">as</span> <span class="nn">sgeom</span>
<span class="kn">import</span> <span class="nn">steps.rng</span> <span class="kn">as</span> <span class="nn">srng</span>
<span class="kn">import</span> <span class="nn">steps.solver</span> <span class="kn">as</span> <span class="nn">ssolver</span>
<span class="kn">import</span> <span class="nn">steps.utilities.meshio</span> <span class="kn">as</span> <span class="nn">meshio</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Next we define some parameters for the simulation, which are intended to remain constant throughout
the script. We start with the potassium channel and define the single-channel conductance, channel
density and reversal potential, keeping to a conductance to 0.036 S/cm2 (see <a class="reference internal" href="#sim"><em>Simulation with Tetexact</em></a> for more on converting continuous conductance to discrete conductance):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Potassium single-channel conductance</span>
<span class="n">K_G</span> <span class="o">=</span> <span class="mf">20.0e-12</span> <span class="c"># Siemens</span>

<span class="c"># Potassium channel density</span>
<span class="n">K_ro</span> <span class="o">=</span> <span class="mf">18.0e12</span> <span class="c"># per square meter</span>

<span class="c"># Potassium reversal potential</span>
<span class="n">K_rev</span> <span class="o">=</span> <span class="o">-</span><span class="mf">77e-3</span> <span class="c"># volts</span>
</pre></div>
</div>
<p>The first thing to note is that, as usual in STEPS, units are s.i., which means in the above example the single channel conductance is given in Siemens and
the reversal potential for the ohmic current is in volts.</p>
<p>Similarly, we define parameters for the sodium channel, also choosing a single-channel conductance
of 20pS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Sodium single-channel conductance</span>
<span class="n">Na_G</span> <span class="o">=</span> <span class="mf">20.0e-12</span> <span class="c"># Siemens</span>

<span class="c"># Sodium channel density</span>
<span class="n">Na_ro</span> <span class="o">=</span> <span class="mf">60.0e12</span> <span class="c"># per square meter</span>

<span class="c"># Sodium reversal potential</span>
<span class="n">Na_rev</span> <span class="o">=</span> <span class="mf">50e-3</span> <span class="c"># volts</span>
</pre></div>
</div>
<p>The HH model also includes a leak conductance, which may also be discretised. The overall conductance is
small compared to maximal potassium and sodium conductances, but we choose a similar channel density to give
a good spatial spread of the conductance, which means a fairly low single-channel conductance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Leak single-channel conductance</span>
<span class="n">L_G</span> <span class="o">=</span> <span class="mf">0.3e-12</span> <span class="c"># Siemens</span>

<span class="c"># Leak density</span>
<span class="n">L_ro</span> <span class="o">=</span> <span class="mf">10.0e12</span> <span class="c"># per square meter</span>

<span class="c"># Leak reversal potential</span>
<span class="n">leak_rev</span> <span class="o">=</span> <span class="o">-</span><span class="mf">54.4e-3</span> <span class="c"># volts</span>
</pre></div>
</div>
<p>The next parameters require a little explanation. Taking the potassium conductance as an example, the
potassium density will convert to a discrete number of channels that will give (approximately) our intended
maximal conductance of 0.036 S/cm^2. In the molecular sense, this means that if all potassium channels
are in the &#8216;open&#8217; conducting state then we will reach the maximal conductance. However, in fact
each individual channel can be in any one of 5 states (including the conducting state) (see <a class="reference internal" href="#figure-7-1"><em>Figure 7.1</em></a>) and these states are
described by separate objects in the STEPS simulation (as we will see later), where the sum of populations of each state should
be equal to the total number of channels. For example, if the surface of the mesh is 100 square microns
by the above density we expect to have a total of 1800 potassium channels in the simulation but at some time
we might have e.g. 400 in the n0 state, 700 in the n1 state, 500 in the n2 state, 150 in the n3 state
and 50 in the conducting n4 state, and the total at any time will be equal to 1800.</p>
<p>So we intend to initialise our populations of channel states to some initial value. The details of how to
calculate the initial condition will not be given here, but the factors used here are steady-state approximations for
the HH model at an initial potential of -65mV. We then give a table of fractional channel state populations (which
add up to a value of 1). For each channel state the factor multiplied by the channel density and the surface area
of the mesh will give our initial population of channels in that state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># A table of potassium channel population factors:</span>
<span class="c"># n0, n1, n2, n3, n4</span>
<span class="n">K_facs</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.21768</span><span class="p">,</span> <span class="mf">0.40513</span><span class="p">,</span> <span class="mf">0.28093</span><span class="p">,</span> <span class="mf">0.08647</span><span class="p">,</span> <span class="mf">0.00979</span> <span class="p">]</span>

<span class="c"># A table of sodium channel population factors</span>
<span class="c"># m0h0, m1h0, m2h0, m3h0, m0h1, m1h1, m2h1, m3h1:</span>
<span class="n">Na_facs</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.34412</span><span class="p">,</span> <span class="mf">0.05733</span><span class="p">,</span> <span class="mf">0.00327</span><span class="p">,</span> <span class="mf">6.0e-05</span><span class="p">,</span> <span class="mf">0.50558</span><span class="p">,</span> <span class="mf">0.08504</span><span class="p">,</span> <span class="mf">0.00449</span><span class="p">,</span> <span class="mf">0.00010</span> <span class="p">]</span>
</pre></div>
</div>
<p>We now define some more important parameters for our simulation. The first is temperature assumed for
the gating kinetics, which we will give in units of degrees celsius but is not directly used in simulation
(as we will see). The second is a current clamp that we intend for one end of the mesh. The third is a
voltage-range for simulation. These parameters will all be described in more detail later:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Temperature for gating kinetics</span>
<span class="n">celsius</span> <span class="o">=</span> <span class="mf">20.0</span>

<span class="c"># Current clamp</span>
<span class="n">Iclamp</span> <span class="o">=</span> <span class="mf">50.0e-12</span> <span class="c"># amps</span>

<span class="c"># Voltage range for gating kinetics in Volts</span>
<span class="n">Vrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">100.0e-3</span><span class="p">,</span> <span class="mf">50e-3</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally we set some simulation control parameters, the number of &#8216;time-points&#8217; to run and
the &#8216;time-step&#8217; at which we will record data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The number of simulation time-points</span>
<span class="n">N_timepoints</span> <span class="o">=</span> <span class="mi">41</span>

<span class="c"># The simulation dt</span>
<span class="n">DT_sim</span> <span class="o">=</span> <span class="mf">1.0e-4</span> <span class="c"># seconds</span>
</pre></div>
</div>
</div>
<div class="section" id="model-specification">
<span id="mod-spec"></span><h3>7.2.2. Model specification<a class="headerlink" href="#model-specification" title="Permalink to this headline">¶</a></h3>
<p>We move on to the biochemical model description. This is quite different from previous chapters, with
new objects to look at, which are important building blocks of any simulation that includes
voltage-dependent processes in STEPS.</p>
<p>To start, we create a Model container object (<a class="reference internal" href="API_model.html#steps.model.Model" title="steps.model.Model"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Model</span></tt></a>) and one surface system
(<a class="reference internal" href="API_model.html#steps.model.Surfsys" title="steps.model.Surfsys"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Surfsys</span></tt></a>), with no volume system necessary for this relatively simple model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mdl</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span>
<span class="n">ssys</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">Surfsys</span><span class="p">(</span><span class="s">&#39;ssys&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">)</span>
</pre></div>
</div>
<p>To make our potassium, sodium and leak channels we need to use two new objects. The <a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a>
objects are used to describe each separate channel state, and <a class="reference internal" href="API_model.html#steps.model.Chan" title="steps.model.Chan"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Chan</span></tt></a> objects group a set of
channel states together to form a channel. At present the role of Channel objects (<a class="reference internal" href="API_model.html#steps.model.Chan" title="steps.model.Chan"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Chan</span></tt></a>)
is mainly conceptual and not functional, with the ChannelState objects (<a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a>)
playing the important roles in simulation: for example, voltage-dependent transitions occur between channel states
and a channel current object is associated with a channel state, both of which we will see later.</p>
<p>The code to create the potassium channel looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Potassium channel</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">Chan</span><span class="p">(</span><span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">)</span>
<span class="n">K_n0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;K_n0&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
<span class="n">K_n1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;K_n1&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
<span class="n">K_n2</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;K_n2&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
<span class="n">K_n3</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;K_n3&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
<span class="n">K_n4</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;K_n4&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> objects look and behave quite similarly to <a class="reference internal" href="API_model.html#steps.model.Spec" title="steps.model.Spec"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Spec</span></tt></a> objects,
with the difference that, as well as the usual string identifier and <a class="reference internal" href="API_model.html#steps.model.Model" title="steps.model.Model"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Model</span></tt></a> container object
arguments, the constructor also expects to see a reference to a <a class="reference internal" href="API_model.html#steps.model.Chan" title="steps.model.Chan"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Chan</span></tt></a> object that conceptually
groups the channel states together. It is obvious to see here which channel configuration each
state is intended to represent.</p>
<p>Similarly we create the sodium channel objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Na</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">Chan</span><span class="p">(</span><span class="s">&#39;Na&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">)</span>
<span class="n">Na_m0h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m0h0&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m1h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m1h0&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m2h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m2h0&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m3h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m3h0&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m0h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m0h1&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m1h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m1h1&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m2h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m2h1&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
<span class="n">Na_m3h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Na_m3h1&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">Na</span><span class="p">)</span>
</pre></div>
</div>
<p>and also the leak channel objects, which only exist in conducting state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Leak channel</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">Chan</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">)</span>
<span class="n">Leak</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">ChanState</span><span class="p">(</span><span class="s">&#39;Leak&#39;</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>We move on to describing the transitions between channel states. Firstly, we describe the transition rates
in the model, as described in <a class="reference internal" href="#mgs"><em>Markov gating scheme</em></a>, and we do so for each using a lambda expressions, which is
a shorthand way to define a function object in Python. We can use any callable function here (as will be
explained later) so we could just as easily use the more familiar <tt class="docutils literal"><span class="pre">def</span></tt> syntax if we wanted to. We also introduce
temperature dependence and use the previously defined <tt class="docutils literal"><span class="pre">celsius</span></tt> variable to find <tt class="docutils literal"><span class="pre">thi</span></tt> at 20 degrees celsius:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Temperature dependence</span>
<span class="n">thi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="p">((</span><span class="n">celsius</span><span class="o">-</span><span class="mf">6.3</span><span class="p">)</span><span class="o">/</span><span class="mf">10.0</span><span class="p">))</span>

<span class="n">_a_n</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mV</span><span class="p">:</span> <span class="n">thi</span><span class="o">*</span><span class="p">((</span><span class="mf">0.01</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mi">10</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">))</span><span class="o">/</span><span class="mf">10.</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

<span class="n">_b_n</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mV</span><span class="p">:</span> <span class="n">thi</span><span class="o">*</span><span class="p">((</span><span class="mf">0.125</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">)</span><span class="o">/</span><span class="mf">80.</span><span class="p">)))</span>

<span class="n">_a_m</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mV</span><span class="p">:</span> <span class="n">thi</span><span class="o">*</span><span class="p">((</span><span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="mi">25</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mi">25</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">))</span><span class="o">/</span><span class="mf">10.</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

<span class="n">_b_m</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mV</span><span class="p">:</span> <span class="n">thi</span><span class="o">*</span><span class="p">((</span><span class="mf">4.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">)</span><span class="o">/</span><span class="mf">18.</span><span class="p">)))</span>


<span class="n">_a_h</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mV</span><span class="p">:</span> <span class="n">thi</span><span class="o">*</span><span class="p">((</span><span class="mf">0.07</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">)</span><span class="o">/</span><span class="mf">20.</span><span class="p">)))</span>

<span class="n">_b_h</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mV</span><span class="p">:</span> <span class="n">thi</span><span class="o">*</span><span class="p">((</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mi">30</span><span class="o">-</span><span class="p">(</span><span class="n">mV</span><span class="o">+</span><span class="mf">65.</span><span class="p">))</span><span class="o">/</span><span class="mf">10.</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<p>We should bear in mind that these functions will expect a voltage to be given in units of millivolts, and
will return the transition rate in unit of /ms.</p>
<p>To define voltage-dependent channel transitions we use a new STEPS object, the &#8216;Voltage-dependent surface reaction&#8217;
(<a class="reference internal" href="API_model.html#steps.model.VDepSReac" title="steps.model.VDepSReac"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.VDepSReac</span></tt></a>). This object may be used to define any reaction in STEPS that is voltage-dependent, which
often involves 1st-order voltage-dependent transitions between different channel states, but also supports
higher order interactions which may include interactions between volume-diffusing molecules and surface-bound molecules
and thus allows modelling of, for example, voltage-dependent channel block. Because all
of these processes are only permitted to occur on a surface and not in a volume, we choose the term
&#8216;voltage-dependent surface reaction&#8217;.
The syntax of creating this object, therefore, shares similarities with <a class="reference internal" href="API_model.html#steps.model.SReac" title="steps.model.SReac"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.SReac</span></tt></a>, but with some
important differences. Let&#8217;s look at a first example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Kn0n1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn0n1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n0</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n1</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">4.</span><span class="o">*</span><span class="n">_a_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">100.0e-3</span><span class="p">,</span> <span class="mf">50e-3</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">])</span>
</pre></div>
</div>
<p>The first few arguments to the <a class="reference internal" href="API_model.html#steps.model.VDepSReac" title="steps.model.VDepSReac"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.VDepSReac</span></tt></a> constructor are identical to those for
<a class="reference internal" href="API_model.html#steps.model.SReac" title="steps.model.SReac"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.SReac</span></tt></a>: In order, a string-identifier is required (which must be unique amongst all objects of the
same type), a reference to a <a class="reference internal" href="API_model.html#steps.model.Surfsys" title="steps.model.Surfsys"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Surfsys</span></tt></a> object, a list of reactants- the &#8216;left-hand side&#8217; arguments
(which may exist in the &#8216;inner&#8217; volume, the surface, or the &#8216;outer&#8217; volume, but not in both volumes) and a list of products- the &#8216;right-hand side&#8217; arguments. The syntax up to this point follows exactly as described for
<a class="reference internal" href="API_model.html#steps.model.SReac" title="steps.model.SReac"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.SReac</span></tt></a> in <a class="reference internal" href="ip3.html"><em>Surface-Volume Reactions (Example: IP3 Model)</em></a>, with one noteworthy difference: now the reactants and products may be
<a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> objects, as well as <a class="reference internal" href="API_model.html#steps.model.Spec" title="steps.model.Spec"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Spec</span></tt></a> objects, or a mixture of both. Indeed,
in the context of reactions in STEPS (voltage-dependent or otherwise) <a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> objects
behave exactly like <a class="reference internal" href="API_model.html#steps.model.Spec" title="steps.model.Spec"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Spec</span></tt></a> objects, with the only difference between the two being that
<a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> objects support additional functionality, namely the ability to conduct current, as we
will see later.
The other arguments, keyword arguments <tt class="docutils literal"><span class="pre">k</span></tt> and <tt class="docutils literal"><span class="pre">vrange</span></tt> require some explanation. The macroscopic reaction &#8216;constant&#8217; is
of course now not a constant at all, but is instead dependent on voltage. To describe the voltage-dependence we pass
a function to argument <tt class="docutils literal"><span class="pre">k</span></tt> which returns the reaction rate as a function of voltage. We tell STEPS to evaluate this
function over a voltage range, which we choose so as to easily cover all voltages we expect the membrane potential to
reach during the simulation. As with other reaction objects, all units are specified as s.i. units, with the exception of
higher-order reactions which are based on Molar units. Since this is a 1st-order reaction we must ensure that the
function passed to the <tt class="docutils literal"><span class="pre">k</span></tt> argument returns in units of /second over the range of potentials passed in units of Volts.
Since this particular voltage-dependent surface reaction object is clearly intended to model the forward n0 to n1
transition, as shown in figure 7.1, we require a factor of 4 to be applied to the <tt class="docutils literal"><span class="pre">_a_n</span></tt> function to cover each possible 0 to 1 transition. To achieve this our
function to <tt class="docutils literal"><span class="pre">k</span></tt> is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">4.</span><span class="o">*</span><span class="n">_a_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">)</span>
</pre></div>
</div>
<p>where the unit conversions should be clear (recall <tt class="docutils literal"><span class="pre">_a_n</span></tt> expects an argument in mV units, and returns /ms).
The <tt class="docutils literal"><span class="pre">vrange</span></tt> argument requires the voltage-range to evaluate the rate-function as a Python sequence in the order
of: minimum voltage, maximum voltage, voltage-step. We should choose the voltage range to cover
what we expect from the simulation, but not by too much since a smaller range gives faster performance, and the voltage-step
should be chosen to give only a small error from linear interpolation between voltage-points. It is a very important point
that if, during a simulation, the membrane potential goes outside the voltage range for any voltage-dependent surface
reaction object located in that membrane the simulation will fail.
In our example we choose a voltage range of -100mV to +50mV, and tell STEPS to evaluate the voltage every 0.1mV, so
the <tt class="docutils literal"><span class="pre">vrange</span></tt> argument is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">100.0e-3</span><span class="p">,</span> <span class="mf">50e-3</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">]</span>
</pre></div>
</div>
<p>In the &#8216;Kn0n1&#8217; example the sequence of voltages was given directly to the <tt class="docutils literal"><span class="pre">vrange</span></tt> argument, but in fact at the beginning
of our script we defined a voltage-range as list <tt class="docutils literal"><span class="pre">Vrange</span></tt>, which we pass to all future VDepSreac objects we create in
this script. The rest of our voltage-dependent channel transitions for the Potassium channel are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Kn1n2</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn1n2&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n1</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n2</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">3.</span><span class="o">*</span><span class="n">_a_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>
<span class="n">Kn2n3</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn2n3&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n2</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n3</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">_a_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>
<span class="n">Kn3n4</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn3n4&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n3</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n4</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">1.</span><span class="o">*</span><span class="n">_a_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>

<span class="n">Kn4n3</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn4n3&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n4</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n3</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">4.</span><span class="o">*</span><span class="n">_b_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>
<span class="n">Kn3n2</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn3n2&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n3</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n2</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">3.</span><span class="o">*</span><span class="n">_b_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>
<span class="n">Kn2n1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn2n1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n2</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n1</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">_b_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>
<span class="n">Kn1n0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Kn1n0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">slhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n1</span><span class="p">],</span> <span class="n">srhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">K_n0</span><span class="p">],</span> \
    <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span> <span class="mf">1.0e3</span> <span class="o">*</span><span class="mf">1.</span><span class="o">*</span><span class="n">_b_n</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span> <span class="o">=</span> <span class="n">Vrange</span><span class="p">)</span>
</pre></div>
</div>
<p>The voltage-dependent surface reactions for the Sodium channel follow. Since there are 20 different possible
transitions (figure 7.2) we need to create 20 <a class="reference internal" href="API_model.html#steps.model.VDepSReac" title="steps.model.VDepSReac"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.VDepSReac</span></tt></a> objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Na_m0h1_m1h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m0h1_m1h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">3.</span><span class="o">*</span><span class="n">_a_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m1h1_m2h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m1h1_m2h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">_a_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m2h1_m3h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m2h1_m3h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">1.</span><span class="o">*</span><span class="n">_a_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>

<span class="n">Na_m3h1_m2h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m3h1_m2h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">3.</span><span class="o">*</span><span class="n">_b_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m2h1_m1h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m2h1_m1h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">_b_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m1h1_m0h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m1h1_m0h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">1.</span><span class="o">*</span><span class="n">_b_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>

<span class="n">Na_m0h0_m1h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m0h0_m1h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">3.</span><span class="o">*</span><span class="n">_a_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m1h0_m2h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m1h0_m2h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">_a_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m2h0_m3h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m2h0_m3h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">1.</span><span class="o">*</span><span class="n">_a_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>

<span class="n">Na_m3h0_m2h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m3h0_m2h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">3.</span><span class="o">*</span><span class="n">_b_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m2h0_m1h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m2h0_m1h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">_b_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m1h0_m0h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m1h0_m0h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="mf">1.</span><span class="o">*</span><span class="n">_b_m</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>

<span class="n">Na_m0h0_m0h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m0h0_m0h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_a_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m1h0_m1h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m1h0_m1h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_a_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m2h0_m2h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m2h0_m2h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_a_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m3h0_m3h1</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m3h0_m3h1&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h0</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h1</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_a_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>

<span class="n">Na_m0h1_m0h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m0h1_m0h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m0h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_b_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m1h1_m1h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m1h1_m1h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m1h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_b_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m2h1_m2h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m2h1_m2h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m2h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_b_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
<span class="n">Na_m3h1_m3h0</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">VDepSReac</span><span class="p">(</span><span class="s">&#39;Na_m3h1_m3h0&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> \
    <span class="n">slhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h1</span><span class="p">],</span> <span class="n">srhs</span><span class="o">=</span><span class="p">[</span><span class="n">Na_m3h0</span><span class="p">],</span> \
        <span class="n">k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">V</span><span class="p">:</span><span class="mf">1.0e3</span><span class="o">*</span><span class="n">_b_h</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="mf">1.0e3</span><span class="p">),</span> <span class="n">vrange</span><span class="o">=</span><span class="n">Vrange</span><span class="p">)</span>
</pre></div>
</div>
<p>The final part of our model specification is to add currents. Presently in STEPS we have the choice of two types of current that have quite different behaviour: Ohmic currents- which are represented by <a class="reference internal" href="API_model.html#steps.model.OhmicCurr" title="steps.model.OhmicCurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.OhmicCurr</span></tt></a> objects- and currents based on the GHK flux equation- represented by <a class="reference internal" href="API_model.html#steps.model.GHKcurr" title="steps.model.GHKcurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.GHKcurr</span></tt></a> objects. Since the Hodgkin-Huxley model utilises Ohmic currents we only need to concern ourselves with those objects here.</p>
<p>The assumption made in STEPS is that Ohmic current objects are used to model currents of ions that play no other important role in the system other than in membrane excitability, and so it is not necessary to add, in this example, ions of sodium and potassium diffusing both extra- and intra-cellularly. Because of the relatively large concentration of these ions simulating diffusion would be incredibly slowing to simulations with no perceptible benefit to accuracy. It is due to these arguments that an Ohmic current in STEPS will not result in transport of ions between compartments. The GHK current objects are able to model ion transport and so should always be used when modelling currents of important signalling ions, a good example of which for many systems is calcium.</p>
<p>Because STEPS is primarily a discrete simulator the Current objects in STEPS are based on single-channel currents. A <a class="reference internal" href="API_model.html#steps.model.OhmicCurr" title="steps.model.OhmicCurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.OhmicCurr</span></tt></a>, applied to a specific <a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> object will result in an Ohmic current through every single Channel in that specific state located in the Membrane (which we will create later) at any given time. Therefore, to create an Ohmic current in STEPS we need to pass information as to which Channel state the current will be applied to, as well as its single-channel conductance to this current, along with the reversal potential. As usual in STEPS all units are based on s.i. units, and so the single-channel conductance unit is siemens and reversal potential unit is volts.</p>
<p>The <a class="reference internal" href="API_model.html#steps.model.OhmicCurr" title="steps.model.OhmicCurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.OhmicCurr</span></tt></a> constructor expects 5 arguments: a string identifier (as usual in STEPS this must be unique amongst other Ohmic current objects), a reference to a <a class="reference internal" href="API_model.html#steps.model.Surfsys" title="steps.model.Surfsys"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Surfsys</span></tt></a> object, a reference to a <a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> to which this current applies (<tt class="docutils literal"><span class="pre">chanstate</span></tt> argument), a single-channel conductance (<tt class="docutils literal"><span class="pre">g</span></tt> argument), and a reversal potential  (<tt class="docutils literal"><span class="pre">erev</span></tt> argument). At the top of our script we already defined conductance and reversal potential for all of our channels in this simulation, i.e. the potassium single-channel conductance <tt class="docutils literal"><span class="pre">K_G</span> <span class="pre">=</span> <span class="pre">20.0e-12</span></tt> Siemens and reversal potential <tt class="docutils literal"><span class="pre">K_rev</span> <span class="pre">=</span> <span class="pre">-77e-3</span></tt> volts, the sodium single-channel conductance <tt class="docutils literal"><span class="pre">Na_G</span> <span class="pre">=</span> <span class="pre">20.0e-12</span></tt> Siemens and reversal potential <tt class="docutils literal"><span class="pre">Na_rev</span> <span class="pre">=</span> <span class="pre">50e-3</span></tt> volts, the leak single-channel conductance <tt class="docutils literal"><span class="pre">L_G</span> <span class="pre">=</span> <span class="pre">0.3e-12</span></tt> Siemens and reversal potential <tt class="docutils literal"><span class="pre">leak_rev</span> <span class="pre">=</span> <span class="pre">-54.4e-3</span></tt> volts, so we use these values when creating the Ohmic current objects. The conducting states of the potassium, sodium and leak currents respectively are <tt class="docutils literal"><span class="pre">K_n4</span></tt>, <tt class="docutils literal"><span class="pre">Na_m3h1</span></tt> and <tt class="docutils literal"><span class="pre">Leak</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OC_K</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">OhmicCurr</span><span class="p">(</span><span class="s">&#39;OC_K&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">chanstate</span><span class="o">=</span><span class="n">K_n4</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">K_G</span><span class="p">,</span> <span class="n">erev</span><span class="o">=</span><span class="n">K_rev</span><span class="p">)</span>
<span class="n">OC_Na</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">OhmicCurr</span><span class="p">(</span><span class="s">&#39;OC_Na&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">chanstate</span><span class="o">=</span><span class="n">Na_m3h1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">Na_G</span><span class="p">,</span> <span class="n">erev</span><span class="o">=</span><span class="n">Na_rev</span><span class="p">)</span>
<span class="n">OC_L</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">OhmicCurr</span><span class="p">(</span><span class="s">&#39;OC_L&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">chanstate</span><span class="o">=</span><span class="n">Leak</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">L_G</span><span class="p">,</span> <span class="n">erev</span><span class="o">=</span><span class="n">leak_rev</span><span class="p">)</span>
</pre></div>
</div>
<p>Now in the STEPS simulation when, for example, the number of potassium channels in state K_n4 is non-zero a potassium conductance will exist equal to the population of K_n4 channel states multiplied by the single channel conductance, and a current will be calculated depending on the simulation voltage relative to the given reversal potential.</p>
</div>
<div class="section" id="geometry-specification">
<span id="geom-spec"></span><h3>7.2.3. Geometry specification<a class="headerlink" href="#geometry-specification" title="Permalink to this headline">¶</a></h3>
<p>With the model completed we move on to geometry specification. To simulate action potential propagation we&#8217;ll demonstrate the rather unusual case of using a long cuboid mesh whereas other simulators may typically assume cylindrical geometry. This is partly to demonstrate that the only restriction on geometry used for the membrane potential calculation in STEPS is that it can be represented by a tetrahedral mesh. Since tetrahedral meshes are capable of representing real cellular geometry with high accuracy this opens up many interesting applications, yet for this example we&#8217;ll stick with a rather basic shape. As in previous sections we&#8217;ll import a mesh in Abaqus format, which represents a cuboid of length 1000µm in the z-axis, and a diameter of 0.44µm (which is an equivalent cylindrical diamter of 0.5µm) in the x and y axes (<a class="reference internal" href="#figure-7-3"><em>Figure 7.3</em></a>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">meshio</span><span class="o">.</span><span class="n">importAbaqus</span><span class="p">(</span><span class="s">&#39;meshes/axon_cube_L1000um_D443nm_equiv0.5_19087tets.inp&#39;</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="figure" id="figure-7-3">
<img alt="_images/HHmesh.png" src="_images/HHmesh.png" style="width: 9.0in; height: 5.81in;" />
<p class="caption"><cite>Figure 7.3: A portion of the tetrahedral mesh representing a cuboid of length 1000µm oriented along the z-axis.</cite></p>
</div>
<p>The following section of code will not be explained in detail, but simply serves two purposes. Firstly, to find the vertices at one end of the cuboid in which a current pulse will be applied (which will be stored in list <tt class="docutils literal"><span class="pre">injverts</span></tt>)- since the long axis of the cuboid in the z-axis these will be the minimum z vertices. Secondly to find the corresponding triangles on that face, which will be excluded from the membrane (stored in list <tt class="docutils literal"><span class="pre">facetris</span></tt>) since this end is intended to be an &#8216;open&#8217; end:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Find the vertices for the current clamp and store in a list</span>
<span class="n">injverts</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nverts</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">getVertex</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">getBoundMin</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mf">0.1e-6</span><span class="p">))):</span>
        <span class="n">injverts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Found &quot;</span><span class="p">,</span> <span class="n">injverts</span><span class="o">.</span><span class="n">__len__</span><span class="p">(),</span> <span class="s">&quot;I_inject vertices&quot;</span>

<span class="n">facetris</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ntris</span><span class="p">):</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">getTri</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">injverts</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">injverts</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">injverts</span><span class="p">)):</span>
        <span class="n">facetris</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Found &quot;</span><span class="p">,</span> <span class="n">facetris</span><span class="o">.</span><span class="n">__len__</span><span class="p">(),</span> <span class="s">&quot;triangles on bottom face&quot;</span>
</pre></div>
</div>
<p>Now we will use a mesh function to find all the triangles on the surface of the mesh and exclude those on the bottom face:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">memb_tris</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">getSurfTris</span><span class="p">())</span>

<span class="c"># Remove triangles on bottom face from membrane triangles</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">facetris</span><span class="p">:</span> <span class="n">memb_tris</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The following section of code, which will also not be described in full detail, simply serves to <tt class="docutils literal"><span class="pre">bin</span></tt> the surface triangles by distance along the z-axis and to store the total area of the bins, which will be used later in the script to convert recorded current to a current density (current per unit area):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Bin the surface triangles for recording current</span>
<span class="n">bins_n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">memb_tris_binned</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">bins_n</span>
<span class="n">mtb_area</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bins_n</span><span class="p">)</span>

<span class="c"># In m</span>
<span class="n">bin_dz</span> <span class="o">=</span> <span class="mf">1000.0e-6</span><span class="o">/</span><span class="n">bins_n</span>

<span class="c"># The centre positions of the bins</span>
<span class="n">bin_pos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">bin_dz</span><span class="o">/</span><span class="mf">2.0</span><span class="p">),</span> <span class="mf">1000e-6</span><span class="p">,</span> <span class="n">bin_dz</span><span class="p">)</span>

<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins_n</span><span class="p">):</span> <span class="n">memb_tris_binned</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>

<span class="c"># Bin the triangles</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">memb_tris</span><span class="p">:</span>
    <span class="n">barycz</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">getTriBarycenter</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bin_pos</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">barycz</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-</span><span class="p">(</span><span class="n">bin_dz</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">barycz</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">+</span><span class="p">(</span><span class="n">bin_dz</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)):</span>
            <span class="n">memb_tris_binned</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">mtb_area</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+=</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">getTriArea</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0e12</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">idx</span> <span class="o">+=</span><span class="mi">1</span>
</pre></div>
</div>
<p>The final piece of geometry manipulation is to find a point at every 10µm along the z-axis at which to record potential. In STEPS it is possible to record potential anywhere in the membrane or conduction volume and from vertices, triangles and tetrahedrons. Here we intend to record the potential at intracellular tetrahedrons along the centre of the cuboid, and so find their indices and store in numpy array <tt class="docutils literal"><span class="pre">pot_tet</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The points along (z) axis at which to record potential</span>
<span class="n">pot_pos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">getBoundMin</span><span class="p">()[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">getBoundMax</span><span class="p">()[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">10e-6</span><span class="p">)</span>
<span class="n">pot_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pot_pos</span><span class="p">)</span>

<span class="n">pot_tet</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pot_n</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s">&#39;uint&#39;</span><span class="p">)</span>

<span class="n">i</span><span class="o">=</span><span class="mi">0</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot_pos</span><span class="p">:</span>
    <span class="c"># Axis is aligned with z-axis</span>
    <span class="n">pot_tet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">findTetByPoint</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">pot_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>Now, much like in previous chapters, we will create a compartment which simply consists of all tetrahedrons in the mesh, and a surface patch which consists of all surface triangles (except those on the minimum z face), which we found earlier and stored in list <tt class="docutils literal"><span class="pre">memb_tris</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create cytosol compartment</span>
<span class="n">cyto</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">TmComp</span><span class="p">(</span><span class="s">&#39;cyto&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ntets</span><span class="p">))</span>

<span class="c"># Create the patch and associate with surface system &#39;ssys&#39;</span>
<span class="n">patch</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">TmPatch</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">memb_tris</span><span class="p">,</span> <span class="n">cyto</span><span class="p">)</span>
<span class="n">patch</span><span class="o">.</span><span class="n">addSurfsys</span><span class="p">(</span><span class="s">&#39;ssys&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And now we create a new and very important object for the membrane potential calculation, the &#8216;membrane&#8217; itself. The membrane object, <a class="reference internal" href="API_geom.html#steps.geom.Memb" title="steps.geom.Memb"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.Memb</span></tt></a>, simply consists of one or more patch objects which must together form one continous surface, although the membrane may be &#8216;open&#8217; or &#8216;closed&#8217; (&#8216;closed&#8217; means all member triangles are directly connected to 3 other membrane triangles and so form a closed surface, and &#8216;open&#8217; means some triangles have fewer than 3 neighbours and so the surface contains holes). Any channels that exist in the patch(es) that comprise(s) the membrane are available to conduct a current (specified by <a class="reference internal" href="API_model.html#steps.model.OhmicCurr" title="steps.model.OhmicCurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.OhmicCurr</span></tt></a> or <a class="reference internal" href="API_model.html#steps.model.GHKcurr" title="steps.model.GHKcurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.GHKcurr</span></tt></a> objects). The INNER compartment(s) to the membrane patches will comprise the &#8216;conduction volume&#8217; representing the intracellular region. The potential at all vertices in the membrane and conduction volume will be calculated and will vary with any channel, capacitive or externally applied currents, relative to the (earthed) extracellular region.</p>
<p>Where the extracellular space is included in simulations the membrane may be comprised of internal mesh triangles, but for this relatively simple model the membrane is formed from triangles on the surface of the mesh and is comprised of only one patch. This patch contains an inner compartment consisting of all tetrahedrons in the mesh, which will form the conduction volume. So we create the membrane:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create the membrane across which the potential will be solved</span>
<span class="n">membrane</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">Memb</span><span class="p">(</span><span class="s">&#39;membrane&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">[</span><span class="n">patch</span><span class="p">],</span> <span class="n">opt_method</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="API_geom.html#steps.geom.Memb" title="steps.geom.Memb"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.Memb</span></tt></a> constructor requires a string identifier argument and a reference to a <a class="reference internal" href="API_geom.html#steps.geom.Tetmesh" title="steps.geom.Tetmesh"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.Tetmesh</span></tt></a> object plus a list of the composite <a class="reference internal" href="API_geom.html#steps.geom.TmPatch" title="steps.geom.TmPatch"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.TmPatch</span></tt></a> objects (here there in only one), and finally an optional argument named <tt class="docutils literal"><span class="pre">opt_method</span></tt>. This allows the choice of a method for optimization of the ordering of vertices in the membrane and conduction volume, which is essential to produce an efficient calculation. Two methods are presently available: 1) a fast ordering of vertices by their position along the principle axis, which is suitable if one axis is much longer than an other (as is the case here) and 2) a slower breadth-first tree iteration, which produces a similar result to method (1) in cable-like structures but offers a significant improvement to simulation efficiency in complex geometries. Although the initial search for (2) can be slow it is possible to save an optimisation in a file for a specific membrane with solver function  <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.saveMembOpt" title="steps.solver.Tetexact.saveMembOpt"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.saveMembOpt()</span></tt></a>, and this optimisation file can then be supplied as an argument to the <a class="reference internal" href="API_geom.html#steps.geom.Memb" title="steps.geom.Memb"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.Memb</span></tt></a> constructor, so each optimisation for any given membrane need only be found once. However, since this example uses a cable-like mesh we can use the faster principle-axis ordering method, and method (2) is recommended when working with complex, realistic geometries.</p>
<p>There is also an optional boolean argument <tt class="docutils literal"><span class="pre">verify</span></tt>, which defaults to False, but if True will verify that the membrane is a suitable surface for the potential calculation- although this verification can take rather a long time for larger meshes, so should only be used when one is not confident in the suitability of the membrane.</p>
</div>
<div class="section" id="simulation-with-tetexact">
<span id="sim"></span><h3>7.2.4. Simulation with <tt class="docutils literal"><span class="pre">Tetexact</span></tt><a class="headerlink" href="#simulation-with-tetexact" title="Permalink to this headline">¶</a></h3>
<p>As always for a stochastic simulation in STEPS, we create the random number generator and provide a random initial seed based on the current time, here with 10,000 possible unique values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create the random number generator</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">srng</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&#39;mt19937&#39;</span><span class="p">,</span><span class="mi">512</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">%</span><span class="mi">10000</span><span class="p">))</span>
</pre></div>
</div>
<p>And with our model, geometry and random number generator created we are ready to create the solver object. The membrane potential calculation in STEPS is an extension to the <a class="reference internal" href="API_solver.html#steps.solver.Tetexact" title="steps.solver.Tetexact"><tt class="xref py py-class docutils literal"><span class="pre">steps.solver.Tetexact</span></tt></a> solver, and creating the Tetexact solver is much like in previous mesh-based examples, with arguments to the constructor of a <a class="reference internal" href="API_model.html#steps.model.Model" title="steps.model.Model"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.Model</span></tt></a> object, a <a class="reference internal" href="API_geom.html#steps.geom.Tetmesh" title="steps.geom.Tetmesh"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.Tetmesh</span></tt></a> object and a <a class="reference internal" href="API_rng.html#steps.rng.RNG" title="steps.rng.RNG"><tt class="xref py py-class docutils literal"><span class="pre">steps.rng.RNG</span></tt></a> object in that order, plus a simple boolean flag that switches on the membrane potential calculation when set to True (and defaults to False):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create solver object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">ssolver</span><span class="o">.</span><span class="n">Tetexact</span><span class="p">(</span><span class="n">mdl</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>If requested to perform the membrane potential calculation (with the boolean argument set to True) a Tetexact solver requires one (and currently only one) <a class="reference internal" href="API_geom.html#steps.geom.Memb" title="steps.geom.Memb"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.Memb</span></tt></a> to exist within the geometry description, and will therefore fail to be created if such an object does not exist.</p>
<p>With the <a class="reference internal" href="API_solver.html#steps.solver.Tetexact" title="steps.solver.Tetexact"><tt class="xref py py-class docutils literal"><span class="pre">steps.solver.Tetexact</span></tt></a> solver successfully created, with the membrane potential calculation included, it is time to set the simulation initial conditions. Much like in previous examples, this requires injecting molecules into a specific location. In this case we wish to inject a number of molecules represented by <a class="reference internal" href="API_model.html#steps.model.ChanState" title="steps.model.ChanState"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.ChanState</span></tt></a> objects in the model description into the membrane surface represented by a <a class="reference internal" href="API_geom.html#steps.geom.TmPatch" title="steps.geom.TmPatch"><tt class="xref py py-class docutils literal"><span class="pre">steps.geom.TmPatch</span></tt></a> object in the geometry description. As we will see, at the solver stage the Channel State objects behave just like Species objects and any solver method previously used for Species objects may be used for Channel State objects, such as <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.setPatchCount" title="steps.solver.Tetexact.setPatchCount"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.setPatchCount()</span></tt></a>, <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.setCompConc" title="steps.solver.Tetexact.setCompConc"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.setCompConc()</span></tt></a> and so on.</p>
<p>At this point we should pause to look at how to specify conductance in STEPS models. Conductance in STEPS comes from <a class="reference internal" href="API_model.html#steps.model.OhmicCurr" title="steps.model.OhmicCurr"><tt class="xref py py-class docutils literal"><span class="pre">steps.model.OhmicCurr</span></tt></a> objects, which provides a single-channel conductance that will be applied to any Channel State molecule to which that conductance in mapped. For example, recall in this model that we created an Ohmic Current called <tt class="docutils literal"><span class="pre">OC_K</span></tt> to represent the potassium current in the simulation, which will apply to Channel State <tt class="docutils literal"><span class="pre">K_n4</span></tt>, with a single-channel conductance of 20 picosiemens and reversal potential of -77mV, with this statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OC_K</span> <span class="o">=</span> <span class="n">smodel</span><span class="o">.</span><span class="n">OhmicCurr</span><span class="p">(</span><span class="s">&#39;OC_K&#39;</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">chanstate</span><span class="o">=</span><span class="n">K_n4</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="mf">20.0e-12</span><span class="p">,</span> <span class="n">erev</span><span class="o">=-</span><span class="mf">77e-3</span><span class="p">)</span>
</pre></div>
</div>
<p>The overall potassium conductance in the simulation at any time will be equal to the number of <tt class="docutils literal"><span class="pre">K_n4</span></tt> Channel States in existence multiplied by the single-channel conductance, with a maximum conductance equal to the highest possible number of <tt class="docutils literal"><span class="pre">K_n4</span></tt> Channel States (the total number of potassium channels).</p>
<p>Other simulators may use different methods from STEPS to specify conductance, and many modellers may be more comfortable working with conductance per unit area, so some care should be taken with the conversion for STEPS models. This typically involves multiplying conductance per unit area by the membrane area to find overall conductance, then injecting the correct amount of channels into the membrane in STEPS to represent this conductance, depending on the single-channel conductance. Since the conducting channels are discrete in STEPS there may be a small discrepancy from the continuous value.</p>
<p>Recall we have specified potassium channel density, <tt class="docutils literal"><span class="pre">K_ro</span></tt>, as 18 per square micron and sodium channel density, <tt class="docutils literal"><span class="pre">Na_ro</span></tt>, as 60 per square micron, previously in our script with statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K_ro</span> <span class="o">=</span> <span class="mf">18.0e12</span> <span class="c"># per square meter</span>
<span class="n">Na_ro</span> <span class="o">=</span> <span class="mf">60.0e12</span> <span class="c"># per square meter</span>
</pre></div>
</div>
<p>When multiplied by single-channel conductance to give maximum potassium conductance of 0.036 Siemens per square cm and sodium conductance of 0.120 Siemens per square cm. So when injecting our channels in STEPS we simply need to multiply these densities by the surface area of the membrane to find the number to inject. An added complication for this model is that we want to inject steady-state initial conditions, so all channel states have some initial non-zero proportion, which we specified previously in lists <tt class="docutils literal"><span class="pre">K_facs</span></tt> and <tt class="docutils literal"><span class="pre">Na_facs</span></tt> (and we will not go into the derivation of the steady-state factors here).</p>
<p>So to inject our channels, first we find the membrane surface area, which is the same as the area of its only constituent patch:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">surfarea</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">getPatchArea</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And call solver method <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.setPatchCount" title="steps.solver.Tetexact.setPatchCount"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.setPatchCount()</span></tt></a> for every Channel State in the model (including leak) to set the initial number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m0h0&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m1h0&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m2h0&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m3h0&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m0h1&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m1h1&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m2h1&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Na_m3h1&#39;</span><span class="p">,</span> <span class="n">Na_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">Na_facs</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>

<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;K_n0&#39;</span><span class="p">,</span> <span class="n">K_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">K_facs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;K_n1&#39;</span><span class="p">,</span> <span class="n">K_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">K_facs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;K_n2&#39;</span><span class="p">,</span> <span class="n">K_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">K_facs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;K_n3&#39;</span><span class="p">,</span> <span class="n">K_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">K_facs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;K_n4&#39;</span><span class="p">,</span> <span class="n">K_ro</span><span class="o">*</span><span class="n">surfarea</span><span class="o">*</span><span class="n">K_facs</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>

<span class="n">sim</span><span class="o">.</span><span class="n">setPatchCount</span><span class="p">(</span><span class="s">&#39;patch&#39;</span><span class="p">,</span> <span class="s">&#39;Leak&#39;</span><span class="p">,</span> <span class="n">L_ro</span> <span class="o">*</span> <span class="n">surfarea</span><span class="p">)</span>
</pre></div>
</div>
<p>One example run of the above code resulted in potassium Channel State populations of 3135, 5834, 4046, 1245 and 141 respectively giving an initial potassium conductance (from K_n4) of 2.8nS (0.00035 Siemens per square cm) and maximum conductance of 288nS (0.036 Siemens per square cm) as desired.</p>
<p>The next few lines of code set some important new simulation variables, all to do with the membranes potential calculation. The first method sets the time-step period for the potential calculation, specified in seconds. This tells STEPS how often to perform the &#8216;EField&#8217; calculation to evaluate potential, and update any voltage-dependent processes in the simulation. The optimal value for this time-step will vary for different simulations, so some things should be kept in mind when making the choice. Firstly, the time-step should be short enough that the voltage change  occuring during each time-step is small and voltage can be assumed constant during each time-step for any voltage-dependent processes in the model. Therefore a large time-step may result in loss of accuracy. Secondly, the shorter the time-step the slower the simulation will be. Thirdly, the time-step must be shorter or equal to the simulation time-step (this is 0.1ms in our model) so that at least one membrane potential calculation can be carried out per simulation time-step. As a rough guide 0.01ms is usually highly accurate, and it is not recommended to exceed 0.1ms. So for this simulation we choose a calculation time-step of 0.01ms (which happens to be the default value):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set dt for membrane potential calculation to 0.01ms</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setEfieldDT</span><span class="p">(</span><span class="mf">1.0e-5</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we set the initial potential of the membrane with an argument given in volts:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialise potential to -65mV</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setMembPotential</span><span class="p">(</span><span class="s">&#39;membrane&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">65e-3</span><span class="p">)</span>
</pre></div>
</div>
<p>Which also happens to be the default.</p>
<p>And we set the specific capacitance of the membrane, in units of Farad per square meter. So for 1 microfarad per square cm this is 0.01 Farad per square meter (which is also the default setting):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set capacitance of the membrane to 1 uF/cm^2 = 0.01 F/m^2</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setMembCapac</span><span class="p">(</span><span class="s">&#39;membrane&#39;</span><span class="p">,</span> <span class="mf">1.0e-2</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally we set bulk resistivity, which is actually a property of the conduction volume encompassed by the membrane. STEPS expects units of ohm.metre here:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set resistivity of the conduction volume to 100 ohm.cm = 1 ohm.meter</span>
<span class="n">sim</span><span class="o">.</span><span class="n">setMembVolRes</span><span class="p">(</span><span class="s">&#39;membrane&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, this is in fact the default setting.</p>
<p>The last initial condition to set is in fact something that will remain unchanged throughout our simulation for this example, which is a constant current injection at one end of the long cubic geometry. This will have an effect of inducing action potentials at the depolarised end, which will then propagate, and a constant current at the right level will ensure a train of action potentials. In STEPS it is possible to inject current to any node in the conduction volume or membrane with solver method <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.setVertIClamp" title="steps.solver.Tetexact.setVertIClamp"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.setVertIClamp()</span></tt></a>, or any membrane triangle (where current will be shared equally between its 3 nodes) with solver method <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.setTriIClamp" title="steps.solver.Tetexact.setTriIClamp"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.setTriIClamp()</span></tt></a>. Here, we have already found the vertices at one end of the geometry, the minimum z end, and stored them in list <tt class="docutils literal"><span class="pre">injverts</span></tt>. We now wish to set the current clamp for each of these vertices as a share of the 50pA current we have already defined in variable <tt class="docutils literal"><span class="pre">Iclamp</span></tt> (<a class="footnote-reference" href="#f2" id="id2">[2]</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set the current clamp</span>
<span class="n">niverts</span> <span class="o">=</span> <span class="n">injverts</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">injverts</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">setVertIClamp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Iclamp</span><span class="o">/</span><span class="n">niverts</span><span class="p">)</span>
</pre></div>
</div>
<p>The current clamp set will remain in existence throughout the simulation, until we specify otherwise.</p>
<p>Just before running the simulation we need to create empty data structures, much like in previous chapters. Here we intend to record potential, along with sodium and potassium currents, by the 10µm bins we previously arranged:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create result structures</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_timepoints</span><span class="p">,</span> <span class="n">pot_n</span><span class="p">))</span>
<span class="n">res_I_Na</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_timepoints</span><span class="p">,</span> <span class="n">bins_n</span><span class="p">))</span>
<span class="n">res_I_K</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_timepoints</span><span class="p">,</span> <span class="n">bins_n</span><span class="p">))</span>
</pre></div>
</div>
<p>So finally we are ready to run the simulation. We will use some new methods to record information from the simulation: <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.getTriOhmicI" title="steps.solver.Tetexact.getTriOhmicI"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.getTriOhmicI()</span></tt></a> to record the current from membrane triangles and <a class="reference internal" href="API_solver.html#steps.solver.Tetexact.getTetV" title="steps.solver.Tetexact.getTetV"><tt class="xref py py-func docutils literal"><span class="pre">steps.solver.Tetexact.getTetV()</span></tt></a> to record potential from tetrahedrons within the conduction volume. At every time-point we will use information found in the geometry section to loop over the binned membrane triangles (by every 10µm along he z-axis) and record current, then loop over an array of tetrahedral indices to record potential from one central tetrahedron at every 10µm along the z-axis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Run the simulation</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_timepoints</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Tpnt: &quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>

    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">DT_sim</span><span class="o">*</span><span class="n">l</span><span class="p">)</span>

    <span class="c"># Loop through membrane triangle bins and record sodium and potassium currents</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins_n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">memb_tris_binned</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="n">res_I_Na</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">b</span><span class="p">]</span><span class="o">+=</span> <span class="n">sim</span><span class="o">.</span><span class="n">getTriOhmicI</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="s">&#39;OC_Na&#39;</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0e12</span>
            <span class="n">res_I_K</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">b</span><span class="p">]</span><span class="o">+=</span> <span class="n">sim</span><span class="o">.</span><span class="n">getTriOhmicI</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="s">&#39;OC_K&#39;</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0e12</span>

        <span class="n">res_I_Na</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">b</span><span class="p">]</span><span class="o">/=</span><span class="n">mtb_area</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="n">res_I_K</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">b</span><span class="p">]</span><span class="o">/=</span><span class="n">mtb_area</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

    <span class="c"># Loop through central tetrahedrons and record potential</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pot_n</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">getTetV</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pot_tet</span><span class="p">[</span><span class="n">p</span><span class="p">]))</span><span class="o">*</span><span class="mf">1.0e3</span>
</pre></div>
</div>
<p>Let&#8217;s assume that we wish to organise our code so that up to now it is all included in one script, which we name &#8216;HH_Approp.py&#8217;, and we will create another script to run the simulation by importing HH_APprop.py and to provide some plotting functions of the collected data. To aid this approach, we finish our HH_APprop.py script with the following line, which creates a tuple of data conveniently structured for the plotting script to use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">results</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span>  <span class="n">pot_pos</span><span class="p">,</span> <span class="n">res_I_Na</span><span class="p">,</span> <span class="n">res_I_K</span><span class="p">,</span> <span class="n">chan_pos</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="plotting-simulation-output">
<h3>7.2.5. Plotting simulation output<a class="headerlink" href="#plotting-simulation-output" title="Permalink to this headline">¶</a></h3>
<p>So now we create our separate module, called &#8216;runHH_APprop.py&#8217; and begin by importing some matplotlib plotting functions, along with the HH_APprop.py module we created:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">HH_APprop</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>That&#8217;s all we need to do to run the simulation. Now we create an array of &#8216;time-points&#8217; to be used in the plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tpnt</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">N_timepoints</span><span class="o">*</span><span class="n">DT_sim</span><span class="p">,</span> <span class="n">DT_sim</span><span class="p">)</span>
</pre></div>
</div>
<p>And create two functions: one to plot potential as along the z-axis at a given &#8216;time-point&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">plotVz</span><span class="p">(</span><span class="n">tidx</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">&gt;=</span> <span class="n">tpnt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;Time index out of range&#39;</span>
        <span class="k">return</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">tidx</span><span class="p">],</span> \
         <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="n">tidx</span><span class="o">*</span><span class="n">DT_sim</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;ms&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">(</span><span class="n">numpoints</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Z-axis (um)&#39;</span><span class="p">)</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Membrane potential (mV)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and another to plot the sodium and potassium currents (separately) along the z-axis at a given &#8216;time-point&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">plotIz</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span> <span class="n">plotstyles</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;--&#39;</span><span class="p">]):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">&gt;=</span> <span class="n">tpnt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;Time index out of range&#39;</span>
        <span class="k">return</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">tidx</span><span class="p">],</span> <span class="n">plotstyles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
         <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;Na: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="n">tidx</span><span class="o">*</span><span class="n">DT_sim</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;ms&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">tidx</span><span class="p">],</span> <span class="n">plotstyles</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
         <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;K: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="n">tidx</span><span class="o">*</span><span class="n">DT_sim</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;ms&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
    <span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Z-axis (um)&#39;</span><span class="p">)</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Current  (pA/um^2)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>With these modules completed, it is now just one statement from the interactive Python command prompt to run the simulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">runHH_APprop</span>
</pre></div>
</div>
<p>With the simulation finished we can use the plotting functions to plot the potential along the z-axis at 1ms, 2ms and 3ms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">plotVz</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">plotVz</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">plotVz</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>And to plot the membrane currents along the z-axis also at 1ms, 2ms and 3ms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">plotIz</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">plotIz</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">plotIz</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runHH_APprop</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Example output from this code is shown below:</p>
<div class="figure" id="figure-7-4">
<img alt="_images/HH_V_update.png" src="_images/HH_V_update.png" style="width: 11.338576in; height: 5.9905504in;" />
<p class="caption"><cite>Figure 7.4: Action potential propagation, displayed at 1ms, 2ms and 3ms.</cite></p>
</div>
<div class="figure" id="figure-7-5">
<img alt="_images/HH_I_update.png" src="_images/HH_I_update.png" style="width: 11.338576in; height: 5.9905504in;" />
<p class="caption"><cite>Figure 7.5: Sodium and potassium currents, displayed at 1ms, 2ms and 3ms.</cite></p>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Hille B: Gating Mechanisms: Kinetic Thinking. In <em>Ion Channels of Excitable Membranes</em>, 3rd ed. Sinauer Associates, Sunderland, MA: 2001:583-589</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>STEPS maintains the convention that the effect of a positive applied current is to make potential more positive, which is the opposite signing convention to channel currents.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="manual_index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. Simulating Membrane Potential</a><ul>
<li><a class="reference internal" href="#markov-gating-scheme">7.1. Markov gating scheme</a></li>
<li><a class="reference internal" href="#modelling-solution">7.2. Modelling solution</a><ul>
<li><a class="reference internal" href="#organisation-of-code">7.2.1. Organisation of code</a></li>
<li><a class="reference internal" href="#model-specification">7.2.2. Model specification</a></li>
<li><a class="reference internal" href="#geometry-specification">7.2.3. Geometry specification</a></li>
<li><a class="reference internal" href="#simulation-with-tetexact">7.2.4. Simulation with <tt class="docutils literal"><span class="pre">Tetexact</span></tt></a></li>
<li><a class="reference internal" href="#plotting-simulation-output">7.2.5. Plotting simulation output</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="sbml_importer.html"
                        title="previous chapter">6. SBML support</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="preliminary_func.html"
                        title="next chapter">8. Preliminary Functionalities</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/memb_pot.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="preliminary_func.html" title="8. Preliminary Functionalities"
             >next</a> |</li>
        <li class="right" >
          <a href="sbml_importer.html" title="6. SBML support"
             >previous</a> |</li>
        <li><a href="manual_index.html">STEPS User Manual 2.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, The STEPS Development Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>